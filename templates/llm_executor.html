{% extends "base.html" %}

{% block title %}{{ title }}{% endblock %}

{% block head_extra %}
<style>
    /* Basic styling for the modal */
    .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1051; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgba(0,0,0,0.5); /* Black w/ opacity */
    }

    .modal-dialog {
        position: relative;
        margin: 5% auto; /* 5% from the top and centered */
        padding: 0;
        width: 80%; /* Could be more or less, depending on screen size */
        max-width: 600px; /* Maximum width */
        pointer-events: none;
    }

    .modal-content {
        position: relative;
        display: flex;
        flex-direction: column;
        width: 100%;
        pointer-events: auto;
        background-color: #fff;
        background-clip: padding-box;
        border: 1px solid rgba(0, 0, 0, 0.2);
        border-radius: 0.3rem;
        outline: 0;
        color: #333; /* Dark text for readability */
    }

    .modal-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        padding: 1rem 1rem;
        border-bottom: 1px solid #dee2e6;
        border-top-left-radius: calc(0.3rem - 1px);
        border-top-right-radius: calc(0.3rem - 1px);
    }

     .modal-title {
        margin-bottom: 0;
        line-height: 1.5;
        font-size: 1.25rem;
     }

    .modal-body {
        position: relative;
        flex: 1 1 auto;
        padding: 1rem;
    }

    .modal-body pre {
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        padding: 0.5rem;
        border-radius: 0.2rem;
        white-space: pre-wrap; /* Wrap long lines */
        word-wrap: break-word; /* Break words if necessary */
        max-height: 300px; /* Limit height and make scrollable */
        overflow-y: auto;
        font-family: monospace; /* Use monospace font for prompts */
        font-size: 0.9em;
    }

    .modal-footer {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-end; /* Align buttons to the right */
        padding: 0.75rem;
        border-top: 1px solid #dee2e6;
        border-bottom-right-radius: calc(0.3rem - 1px);
        border-bottom-left-radius: calc(0.3rem - 1px);
    }

    .modal-footer > * {
       margin: 0.25rem;
    }

    /* Style inputs inside modal */
    #modalInput {
        flex-grow: 1; /* Take available space */
        margin-right: 0.5rem; /* Space before button */
    }

    /* Style confirmation buttons */
    #modalConfirmYes, #modalConfirmNo {
        margin-left: 0.5rem;
    }

</style>
{% endblock %}


{% block tab_content %}
<div class="tab-pane fade show active" id="llm-executor" role="tabpanel" aria-labelledby="llm-executor-tab">
    <div class="card mt-3">
        <div class="card-header">
            LLM Task Executor
        </div>
        <div class="card-body">
            <form id="execute-form">
                <div class="mb-3">
                    <label for="prompt" class="form-label">Task Prompt:</label>
                    <textarea class="form-control" id="prompt" name="prompt" rows="5" placeholder="Enter your task description (e.g., 'Install nginx and start the service', 'Check disk space on /var')"></textarea>
                </div>
                <div class="mb-3 row">
                     <label for="max_retries" class="col-sm-3 col-form-label">Max Retries on Failure:</label>
                    <div class="col-sm-3">
                         <input type="number" class="form-control" id="max_retries" name="max_retries" value="3" min="0" max="10">
                    </div>
                </div>
                 <button type="submit" id="execute-button" class="btn btn-primary">
                    <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style="display: none;" id="execute-spinner"></span>
                    Execute Task
                </button>
                 <span id="task-status-message" class="ms-3 text-muted"></span>
            </form>

            <hr>

            <div id="results-area" class="mt-3">
                <h5>Results:</h5>
                <div id="results-log" style="white-space: pre-wrap; background-color: #f8f9fa; border: 1px solid #eee; padding: 10px; min-height: 100px; max-height: 500px; overflow-y: auto; font-family: monospace; font-size: 0.9em;">
                    Task results will appear here...
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Input Modal -->
<div class="modal" id="inputModal" tabindex="-1" aria-labelledby="inputModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="inputModalLabel">Input Required</h5>
        <!-- Optional: Add a close button if needed, but submission is primary action
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        -->
      </div>
      <div class="modal-body">
        <p>The running task requires input. Please review the prompt below:</p>
        <pre id="modalPromptText">Prompt text will appear here.</pre>
        <div id="modalInputArea" class="mt-3">
             <label for="modalInput" class="form-label">Your Response:</label>
             <input type="text" class="form-control" id="modalInput" placeholder="Enter your response here">
        </div>
         <div id="modalPasswordArea" class="mt-3" style="display: none;">
             <label for="modalPasswordInput" class="form-label">Password:</label>
             <input type="password" class="form-control" id="modalPasswordInput" placeholder="Enter password">
        </div>
        <div id="modalConfirmationArea" class="mt-3" style="display: none;">
            <p>Do you want to proceed?</p>
            <!-- Buttons handled in footer -->
        </div>
      </div>
      <div class="modal-footer">
         <!-- Generic Input Submit -->
         <button type="button" class="btn btn-primary" id="modalSubmit">Submit Input</button>
         <!-- Confirmation Buttons -->
         <button type="button" class="btn btn-success" id="modalConfirmYes" style="display: none;">Yes</button>
         <button type="button" class="btn btn-danger" id="modalConfirmNo" style="display: none;">No</button>
         <!-- Password Submit -->
         <button type="button" class="btn btn-primary" id="modalSubmitPassword" style="display: none;">Submit Password</button>
         <!-- Optional Cancel/Abort Button -->
         <!-- <button type="button" class="btn btn-secondary" id="modalCancel">Cancel Task (Not Implemented)</button> -->
      </div>
    </div>
  </div>
</div>

{% endblock %}


{% block scripts_extra %}
<script>
    // Global variables for task state
    let currentTaskId = null;
    let pollIntervalId = null;
    const pollIntervalMs = 2000; // Check status every 2 seconds

    const executeForm = document.getElementById('execute-form');
    const executeButton = document.getElementById('execute-button');
    const executeSpinner = document.getElementById('execute-spinner');
    const resultsLog = document.getElementById('results-log');
    const taskStatusMessage = document.getElementById('task-status-message');

    // Modal elements
    const inputModal = new bootstrap.Modal(document.getElementById('inputModal'), {
        keyboard: false, // Prevent closing with Esc key if needed
        backdrop: 'static' // Prevent closing by clicking background
    });
    const modalPromptText = document.getElementById('modalPromptText');
    const modalInputArea = document.getElementById('modalInputArea');
    const modalInput = document.getElementById('modalInput');
    const modalPasswordArea = document.getElementById('modalPasswordArea');
    const modalPasswordInput = document.getElementById('modalPasswordInput');
    const modalConfirmationArea = document.getElementById('modalConfirmationArea');
    const modalSubmitButton = document.getElementById('modalSubmit');
    const modalConfirmYesButton = document.getElementById('modalConfirmYes');
    const modalConfirmNoButton = document.getElementById('modalConfirmNo');
    const modalSubmitPasswordButton = document.getElementById('modalSubmitPassword');


    // Function to display results
    function displayResults(data) {
        let output = `Task ID: ${currentTaskId}\n`;
        output += `Overall Success: ${data.overall_success}\n\n`;
        output += `Attempt History:\n----------------\n`;

        if (data.results && data.results.length > 0) {
            data.results.forEach(attempt => {
                output += `Attempt ${attempt.attempt}:\n`;
                output += `  LLM Commands:\n${attempt.llm_commands ? attempt.llm_commands.map(cmd => `    $ ${cmd}`).join('\n') : '    (None)'}\n`;
                output += `  Execution Success: ${attempt.execution_success}\n`;
                if (attempt.stdout) {
                     output += `  Output/Log:\n${attempt.stdout}\n`; // Already filtered
                }
                if (attempt.stderr) {
                    output += `  Errors:\n${attempt.stderr}\n`;
                }
                 output += `----------------\n`;
            });
        } else if (data.error) {
             output += `Task Failed Critically: ${data.error}\n`;
        } else {
            output += "(No attempt data available)\n";
        }
        resultsLog.textContent = output;
    }

    // Function to stop polling and reset UI
    function stopPollingAndReset() {
        if (pollIntervalId) {
            clearInterval(pollIntervalId);
            pollIntervalId = null;
        }
        currentTaskId = null;
        executeButton.disabled = false;
        executeSpinner.style.display = 'none';
        taskStatusMessage.textContent = '';
         // Ensure modal is hidden
        inputModal.hide();
    }

    // Function to check task status
    async function checkTaskStatus() {
        if (!currentTaskId) return;

        console.log(`Polling status for task ${currentTaskId}...`);
        try {
            const response = await fetch(`/task_status/${currentTaskId}`);
            if (!response.ok) {
                console.error(`Error fetching status: ${response.status}`);
                taskStatusMessage.textContent = `Error: ${response.status}`;
                // Decide if polling should stop on error
                // stopPollingAndReset();
                 if (response.status === 404) { // Task not found, likely finished and cleaned up or invalid ID
                     console.warn("Task ID not found during polling. Stopping.");
                     resultsLog.textContent += "\n\nPolling stopped: Task ID not found (may have completed or timed out).";
                     stopPollingAndReset();
                 }
                 if (response.status === 403) { // Forbidden
                    console.warn("Access denied polling task status. Stopping.");
                    resultsLog.textContent += "\n\nPolling stopped: Access denied.";
                    stopPollingAndReset();
                }
                return;
            }

            const data = await response.json();
            console.log("Status data:", data);
            taskStatusMessage.textContent = `Status: ${data.status}`;

            if (data.status === 'complete' || data.status === 'failed') {
                taskStatusMessage.textContent = `Status: ${data.status}`;
                if (data.result) {
                    displayResults(data.result);
                } else {
                     resultsLog.textContent += `\n\nTask ${data.status}, but no final result data received.`;
                }
                stopPollingAndReset();
            } else if (data.prompt_needed) {
                console.log("Input needed!");
                // Show modal based on input_type
                modalPromptText.textContent = data.prompt_text || '(No prompt text provided)';

                // Hide all input/button types first
                modalInputArea.style.display = 'none';
                modalPasswordArea.style.display = 'none';
                modalConfirmationArea.style.display = 'none';
                modalSubmitButton.style.display = 'none';
                modalConfirmYesButton.style.display = 'none';
                modalConfirmNoButton.style.display = 'none';
                modalSubmitPasswordButton.style.display = 'none';

                if (data.input_type === 'confirmation') {
                    document.getElementById('inputModalLabel').textContent = 'Confirmation Required';
                    modalConfirmationArea.style.display = 'block';
                    modalConfirmYesButton.style.display = 'inline-block';
                    modalConfirmNoButton.style.display = 'inline-block';
                } else if (data.input_type === 'password') {
                     document.getElementById('inputModalLabel').textContent = 'Password Required';
                    modalPasswordArea.style.display = 'block';
                    modalSubmitPasswordButton.style.display = 'inline-block';
                    modalPasswordInput.value = ''; // Clear previous input
                    modalPasswordInput.focus();
                } else { // Default to generic text input
                     document.getElementById('inputModalLabel').textContent = 'Input Required';
                    modalInputArea.style.display = 'block';
                    modalSubmitButton.style.display = 'inline-block';
                    modalInput.value = ''; // Clear previous input
                    modalInput.focus();
                }

                 // Ensure the modal is shown (Bootstrap 5)
                 // Check if it's already shown to avoid flicker? Might not be necessary.
                 const modalElement = document.getElementById('inputModal');
                 const modalInstance = bootstrap.Modal.getInstance(modalElement);
                 if (!modalInstance || !modalElement.classList.contains('show')) {
                     inputModal.show();
                 }

                // Polling continues in the background while modal is shown
            } else {
                 // Task is running, started, resuming - hide modal if it was somehow left open
                 inputModal.hide();
            }

        } catch (error) {
            console.error('Error during polling:', error);
            taskStatusMessage.textContent = 'Polling Error';
            // Consider stopping polling on network errors?
        }
    }

     // Function to submit input from the modal
    async function submitInput(inputValue) {
        if (!currentTaskId) return;

        console.log(`Submitting input for ${currentTaskId}: ${inputValue.substring(0, 20)}...`);
        inputModal.hide(); // Hide modal immediately
        taskStatusMessage.textContent = 'Submitting input...';

        try {
            const response = await fetch(`/provide_input/${currentTaskId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ user_input: inputValue }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                console.error(`Error submitting input: ${response.status}`, errorData);
                resultsLog.textContent += `\n\nError submitting input: ${errorData.message || response.status}`;
                taskStatusMessage.textContent = `Error: ${errorData.message || response.status}`;
                // Decide if we should stop polling here
                 if (response.status === 404 || response.status === 409 || response.status === 403) {
                     stopPollingAndReset(); // Stop if task not found, not waiting, or forbidden
                 }
            } else {
                 const data = await response.json();
                 console.log("Input submission response:", data);
                 taskStatusMessage.textContent = 'Input submitted, resuming...';
                 // Polling will eventually pick up the 'complete' or 'failed' status
            }
        } catch (error) {
            console.error('Network error submitting input:', error);
            resultsLog.textContent += '\n\nNetwork error submitting input.';
            taskStatusMessage.textContent = 'Network Error';
        }
    }

    // Event listener for the main execute form
    executeForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (currentTaskId) {
            alert("A task is already running.");
            return;
        }

        const prompt = document.getElementById('prompt').value;
        const maxRetries = document.getElementById('max_retries').value;

        if (!prompt.trim()) {
            alert("Please enter a prompt.");
            return;
        }

        executeButton.disabled = true;
        executeSpinner.style.display = 'inline-block';
        resultsLog.textContent = 'Starting task...'; // Clear previous results
        taskStatusMessage.textContent = 'Starting...';

        try {
            const response = await fetch('/execute', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ prompt: prompt, max_retries: maxRetries }),
            });

            const data = await response.json();

            if (!response.ok) {
                console.error('Error starting task:', data);
                resultsLog.textContent = `Error starting task: ${data.message || response.status}`;
                stopPollingAndReset(); // Reset UI on failure to start
            } else {
                currentTaskId = data.task_id;
                resultsLog.textContent = `Task started with ID: ${currentTaskId}\nPolling for status...`;
                taskStatusMessage.textContent = `Status: ${data.status}`;
                // Start polling
                if (pollIntervalId) clearInterval(pollIntervalId); // Clear any old interval
                pollIntervalId = setInterval(checkTaskStatus, pollIntervalMs);
                checkTaskStatus(); // Immediate first check
            }
        } catch (error) {
            console.error('Network error starting task:', error);
            resultsLog.textContent = 'Network error starting task.';
            stopPollingAndReset(); // Reset UI on network error
        }
    });

    // Event listeners for modal buttons
    modalSubmitButton.addEventListener('click', () => {
        submitInput(modalInput.value);
    });

    modalInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
             event.preventDefault(); // Prevent potential form submission if modal is inside one
             submitInput(modalInput.value);
        }
    });

     modalSubmitPasswordButton.addEventListener('click', () => {
        submitInput(modalPasswordInput.value);
        modalPasswordInput.value = ''; // Clear password field after submission attempt
    });

     modalPasswordInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
             event.preventDefault();
             submitInput(modalPasswordInput.value);
             modalPasswordInput.value = '';
        }
    });

    modalConfirmYesButton.addEventListener('click', () => {
        submitInput('yes');
    });

    modalConfirmNoButton.addEventListener('click', () => {
        submitInput('no'); // Or maybe send a specific "cancel" signal? For now, 'no'.
    });

</script>
{% endblock %}